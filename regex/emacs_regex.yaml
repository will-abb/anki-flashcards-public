"regex with newlines": "‘\n’ doesn’t always match a newline; to do that, type C-q C-j instead"
"\\&": "'\\&': In the replacement string (TO-STRING), '\\&' stands for the entire text that matched the regular expression (REGEXP). This allows you to include the whole matched text in the replacement. Example: Replacing 'cat' with 'animal (cat)' in a sentence. REGEXP: 'cat', TO-STRING: 'animal (\\&)'. 'The cat sat.' becomes 'The animal (cat) sat.'"
"\\=N": "Special Sequence '\\=N': In the replacement string (TO-STRING), '\\=N' refers to the text that matched the Nth group (enclosed in '\\(...\\)') in the REGEXP. N is a 1-based index. Example: Capturing first name and last name. REGEXP: '\\(\\w+\\) \\(\\w+\\)', TO-STRING: 'Last Name: \\=2, First Name: \\=1'. 'John Doe' becomes 'Last Name: Doe, First Name: John.'"
"Embedded Lisp Expressions": "Embedded Lisp Expressions: Regular expressions in Emacs can include Lisp expressions for dynamic replacement. This is indicated by '\\,' followed by the Lisp expression. Example: Incrementing numbers. REGEXP: '\\([0-9]+\\)', TO-STRING: '\\,(number-to-string (+ 1 (string-to-number \\&)))'. 'Version 1' becomes 'Version 2.'"
"[]": "Character Class: Matches any one of the characters enclosed in the brackets. If the first character after the '[' is '^', it matches any character not in the list. Example: '[abc]' matches 'a', 'b', or 'c'. '[^abc]' matches any character except 'a', 'b', or 'c'."
".": "Any Character: Matches any single character except newline. Example: 'a.b' matches any three-character string that begins with 'a' and ends with 'b', such as 'acb', 'a$b'."
"*": "Zero or More Repetitions: Matches the preceding element zero or more times. Example: 'ab*c' matches 'ac', 'abc', 'abbc', etc."
"+": "One or More Repetitions: Matches the preceding element one or more times. Example: 'ab+c' matches 'abc', 'abbc', but not 'ac'."
"?": "Zero or One Repetition: Matches the preceding element zero or one time. Example: 'ab?c' matches either 'ac' or 'abc'."
"|": "Alternation: Acts as an OR operator. Matches either the expression before or the expression after the symbol. Example: 'cat|dog' matches either 'cat' or 'dog'."
"()": "Grouping: Groups multiple tokens together and remembers the text matched by them for later use. Example: '(abc)+' matches one or more sequences of 'abc', such as 'abc' or 'abcabc'."
"\\": "Escape Character: Used to escape a special character, turning it into a literal, or to signify a special sequence. Example: '\\.\\*' matches a literal period followed by an asterisk."
"^": "Beginning of Line: Matches the start of a line. Example: '^abc' matches 'abc' at the start of a line."
"$": "End of Line: Matches the end of a line. Example: 'abc$' matches 'abc' at the end of a line."
"\\w": "Word Character: Matches any word-constituent character (alphanumeric and underscore). Example: '\\w+' matches any word like 'abc', '123', 'a1b2'."
"\\W": "Non-Word Character: Matches any character that is not a word-constituent character. Example: '\\W+' matches any sequence of non-word characters like '!@#', '%^', etc."
"\\b": "Word Boundary: Matches the empty string, but only at the beginning or end of a word. Example: '\\bcat\\b' matches 'cat' when it is a whole word."
"\\B": "Non-Word Boundary: Matches the empty string, but not at the beginning or end of a word. Example: '\\Bcat\\B' matches 'cat' within a word like 'educate' but not as a separate word."
"{n,m}": "Quantifiers '{n,m}': Matches a preceding element at least 'n' and not more than 'm' times. Example: 'a{2,3}' matches 'aa' or 'aaa'."
"? non-greedy": "Non-Greedy Matching '?': Makes a quantifier such as '+', '*', or '?' non-greedy, meaning it matches the fewest possible characters. Example: 'a+?' matches the first 'a' in 'aaa'. Example: HTML Tag Extractiondf Imagine you have a string containing HTML content, and you want to extract the content of the first <div> tag. Consider the following HTML string:\nhtml Copy code <html> <div>Hello World</div> <div>Another Message</div> </html> Objective: Extract the content of the first <div> tag.\nGreedy Approach (Problematic):\nUsing a greedy regex like <div>.*</div> would match the entire string from the first opening <div> to the last closing </div>. So, it would match <div>Hello World</div><div>Another Message</div>, which is not what we want. Non-Greedy Approach (Solution):\nUsing a non-greedy regex like <div>.*?</div> changes the behavior. The *? modifier makes the .* part match as few characters as possible. This regex will match only <div>Hello World</div>, which is exactly the first <div> block's content. The non-greedy ? modifier is essential here because it prevents the regex engine from overshooting the intended match. It's particularly useful in parsing tasks where the text structures have repeating patterns (like HTML tags, certain types of log files, etc.) and you need to isolate specific, smallest matching segments."
"*?": "Non-Greedy Matching '*?': Matches the preceding element zero or more times, but as few times as possible. Example: '<.*?>' matches the first HTML tag in '<a><b></b></a>'."
"+?": "Non-Greedy Matching '+?': Matches the preceding element one or more times, but as few times as possible. Example: 'a+?' matches the first 'a' in 'aaa' instead of the entire string."
"{n,m}?": "Non-Greedy Quantifier '{n,m}?': Matches the preceding element at least 'n' and not more than 'm' times, but as few times as possible. Example: 'a{2,3}?' matches 'aa' in 'aaa'."
"(?=...)": "Positive Lookahead '(?=...)': Asserts that the following characters in the string are as specified after '=?'. Does not consume characters. Example: 'Isaac (?=Newton)' matches 'Isaac ' only if it's followed by 'Newton'."
"(?!...)": "Negative Lookahead '(?!...)': Asserts that the following characters in the string are not as specified after '?!'. Does not consume characters. Example: 'Isaac (?!Asimov)' matches 'Isaac ' only if it's not followed by 'Asimov'."
"[a-z]": "'[a-z]': Matches any character within the specified range from 'a' to 'z'. Example: '[a-c]' matches 'a', 'b', or 'c'."
"[0-9]": "'[0-9]': Matches any digit within the specified range from '0' to '9'. Example: '[1-3]' matches '1', '2', or '3'."
"\\d": "Digit Character: Matches any digit character (0-9). Example: '\\d+' matches any sequence of digits like '123', '0045'."
"\\D": "Non-Digit Character: Matches any non-digit character. Example: '\\D+' matches any sequence of non-digit characters like 'abc', '!@#'."
"\\s": "Whitespace Character: Matches any whitespace character including space, tab, form-feed, etc. Example: '\\s+' matches any sequence of whitespace characters."
"\\S": "Non-Whitespace Character: Matches any character that is not a whitespace character. Example: '\\S+' matches any sequence of non-whitespace characters."
"\\A": "Beginning of String: Matches only at the beginning of the string. Example: '\\AThe' matches 'The' in 'The start' but not in 'At the start'."
"\\Z": "End of String or before newline at end: Matches only at the end of the string, or before a newline character at the end of the string. Example: 'end\\Z' matches 'end' in 'The end' and 'The end\\n'."
"(?<=...)": "Positive Lookbehind '(?<=...)': Asserts that the preceding characters in the string are as specified after '(?<='. Does not consume characters. Example: '(?<=\\bcar)pet' matches 'pet' in 'carpet' but not in 'carpeted'."
"(?<!...)": "Negative Lookbehind '(?<!...)': Asserts that the preceding characters in the string are not as specified after '(?<!'. Does not consume characters. Example: '(?<!car)pet' matches 'pet' in 'carpeted' but not in 'carpet'."
"[^[:class:]]": "Negated POSIX Character Class: Matches characters not in the specified POSIX class. Example: '[^[:digit:]]' matches any non-digit character."
"(?i)": "Case Insensitive Flag: Makes the regex match case insensitive. Example: '(?i)abc' matches 'Abc', 'aBc', 'ABC', etc."
"[[:alpha:]]": "Alphabetic Characters: Matches any alphabetic character. Equivalent to [a-zA-Z]."
"[[:lower:]]": "Lowercase Characters: Matches any lowercase alphabetic character."
"[[:upper:]]": "Uppercase Characters: Matches any uppercase alphabetic character."
"[[:alnum:]]": "Alphanumeric Characters: Matches any alphanumeric character. Equivalent to [a-zA-Z0-9]."
"[[:punct:]]": "Punctuation Characters: Matches any punctuation character."
"[[:space:]]": "Space Characters: Matches any whitespace character, including space, tab, newline, etc."
"\\0nnn": "Octal Character: Matches a character with the octal value 'nnn'."
